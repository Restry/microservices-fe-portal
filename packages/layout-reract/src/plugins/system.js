/*
* SystemJS v0.21.6 Dev
*/
!(function () {
    const p = typeof window !== 'undefined' && typeof document !== 'undefined'; const d = typeof process !== 'undefined' && process.versions && process.versions.node; const a = typeof process !== 'undefined' && typeof process.platform === 'string' && process.platform.match(/^win/); const w = typeof self !== 'undefined' ? self : global; const t = typeof Symbol !== 'undefined'; function e(e) { return t ? Symbol() : `@@${e}`; } let y; const k = t && Symbol.toStringTag; if (typeof document !== 'undefined' && document.getElementsByTagName) { if (!(y = document.baseURI)) { const r = document.getElementsByTagName('base'); y = r[0] && r[0].href || window.location.href; } } else typeof location !== 'undefined' && (y = location.href); if (y) { const n = (y = y.split('#')[0].split('?')[0]).lastIndexOf('/'); n !== -1 && (y = y.substr(0, n + 1)); } else { if (typeof process === 'undefined' || !process.cwd) throw new TypeError('No environment baseURI'); y = `file://${a ? '/' : ''}${process.cwd()}`, a && (y = y.replace(/\\/g, '/')); }y[y.length - 1] !== '/' && (y += '/'); const i = new Error(0, '_').fileName == '_'; function l(e, t) { p || (t = t.replace(a ? /file:\/\/\//g : /file:\/\//g, '')); let r; const n = `${e.message || e}\n  ${t}`; r = i && e.fileName ? new Error(n, e.fileName, e.lineNumber) : new Error(n); const o = e.originalErr ? e.originalErr.stack : e.stack; return r.stack = d ? `${n}\n  ${o}` : o, r.originalErr = e.originalErr || e, r; } function f(e, t) { throw new RangeError(`Unable to resolve "${e}" to ${t}`); } const g = /\\/g; function b(e, t) { e[0] !== ' ' && e[e.length - 1] !== ' ' || (e = e.trim()); const r = t && t.substr(0, t.indexOf(':') + 1); const n = e[0]; const o = e[1]; if (n === '/' && o === '/') return r || f(e, t), e.indexOf('\\') !== -1 && (e = e.replace(g, '/')), r + e; if (n === '.' && (o === '/' || o === '.' && (e[2] === '/' || e.length === 2 && (e += '/')) || e.length === 1 && (e += '/')) || n === '/') { e.indexOf('\\') !== -1 && (e = e.replace(g, '/')); let i; const a = !r || t[r.length] !== '/'; if (i = a ? (void 0 === t && f(e, t), t) : t[r.length + 1] === '/' ? r !== 'file:' ? (i = t.substr(r.length + 2)).substr(i.indexOf('/') + 1) : t.substr(8) : t.substr(r.length + 1), n === '/') { if (!a) return t.substr(0, t.length - i.length - 1) + e; f(e, t); } for (var s = i.substr(0, i.lastIndexOf('/') + 1) + e, u = [], l = -1, c = 0; c < s.length; c++) if (l === -1) if (s[c] !== '.')l = c; else { if (s[c + 1] !== '.' || s[c + 2] !== '/' && c + 2 !== s.length) { if (s[c + 1] !== '/' && c + 1 !== s.length) { l = c; continue; }c += 1; } else u.pop(), c += 2; a && u.length === 0 && f(e, t); } else s[c] === '/' && (u.push(s.substring(l, c + 1)), l = -1); return l !== -1 && u.push(s.substr(l)), t.substr(0, t.length - i.length) + u.join(''); } return e.indexOf(':') !== -1 ? d && e[1] === ':' && e[2] === '\\' && e[0].match(/[a-z]/i) ? `file:///${e.replace(g, '/')}` : e : void 0; } const o = Promise.resolve(); function s(r) { if (r.values) return r.values(); if (typeof Symbol === 'undefined' || !Symbol.iterator) throw new Error('Symbol.iterator not supported in this browser'); const e = {}; return e[Symbol.iterator] = function () { const e = Object.keys(r); let t = 0; return { next() { return t < e.length ? { value: r[e[t++]], done: !1 } : { value: void 0, done: !0 }; } }; }, e; } function u() { this.registry = new O(); } function c(e) { if (void 0 !== e) { if (e instanceof j == !1 && e[k] !== 'module') throw new TypeError('Module instantiation did not return a valid namespace object.'); return e; } }(u.prototype.constructor = u).prototype.import = function (t, r) { if (typeof t !== 'string') throw new TypeError('Loader import method must be passed a module key string'); const e = this; return o.then(() => e[m](t, r)).then(c).catch(e => { throw l(e, `Loading ${t}${r ? ` from ${r}` : ''}`); }); }; const h = u.resolve = e('resolve'); var m = u.resolveInstantiate = e('resolveInstantiate'); function v(e) { if (void 0 === e) throw new RangeError('No resolution found.'); return e; }u.prototype[m] = function (e, t) { const r = this; return r.resolve(e, t).then(e => r.registry.get(e)); }, u.prototype.resolve = function (t, r) { const e = this; return o.then(() => e[h](t, r)).then(v).catch(e => { throw l(e, `Resolving ${t}${r ? ` to ${r}` : ''}`); }); }; const x = typeof Symbol !== 'undefined' && Symbol.iterator; const E = e('registry'); function O() { this[E] = {}; }x && (O.prototype[Symbol.iterator] = function () { return this.entries()[Symbol.iterator](); }, O.prototype.entries = function () { const t = this[E]; return s(Object.keys(t).map(e => [e, t[e]])); }), O.prototype.keys = function () { return s(Object.keys(this[E])); }, O.prototype.values = function () { const t = this[E]; return s(Object.keys(t).map(e => t[e])); }, O.prototype.get = function (e) { return this[E][e]; }, O.prototype.set = function (e, t) { if (!(t instanceof j || t[k] === 'module')) throw new Error('Registry must be set with an instance of Module Namespace'); return this[E][e] = t, this; }, O.prototype.has = function (e) { return Object.hasOwnProperty.call(this[E], e); }, O.prototype.delete = function (e) { return !!Object.hasOwnProperty.call(this[E], e) && (delete this[E][e], !0); }; const S = e('baseObject'); function j(e) { Object.defineProperty(this, S, { value: e }), Object.keys(e).forEach(P, this); } function P(e) { Object.defineProperty(this, e, { enumerable: !0, get() { return this[S][e]; } }); }j.prototype = Object.create(null), k && Object.defineProperty(j.prototype, k, { value: 'Module' }); const _ = Promise.resolve(); const R = e('register-internal'); function M() { u.call(this); const r = this.registry.delete; this.registry.delete = function (e) { let t = r.call(this, e); return n.hasOwnProperty(e) && !n[e].linkRecord && (delete n[e], t = !0), t; }; var n = {}; this[R] = { lastRegister: void 0, records: n }, this.trace = !1; } const C = ((M.prototype = Object.create(u.prototype)).constructor = M).instantiate = e('instantiate'); function L(e, t, r) { return e.records[t] = { key: t, registration: r, module: void 0, importerSetters: void 0, loadError: void 0, evalError: void 0, linkRecord: { instantiatePromise: void 0, dependencies: void 0, execute: void 0, executingRequire: !1, moduleObj: void 0, setters: void 0, depsInstantiatePromise: void 0, dependencyInstantiations: void 0, evaluatePromise: void 0 } }; } function A(c, d, f, p, g) { return f.instantiatePromise || (f.instantiatePromise = (d.registration ? _ : _.then(() => { return g.lastRegister = void 0, c[C](d.key, c[C].length > 1 && (t = d, r = g, function () { const e = r.lastRegister; return e ? (r.lastRegister = void 0, t.registration = e, !0) : !!t.registration; })); let t; let r; })).then(e => { if (void 0 !== e) { if (!(e instanceof j || e[k] === 'module')) throw new TypeError('Instantiate did not return a valid Module object.'); return delete g.records[d.key], c.trace && I(c, d, f), p[d.key] = e; } let t; let r; let n; let o; let i; let a; let s; let u; const l = d.registration; if (d.registration = void 0, !l) throw new TypeError('Module instantiation did not call an anonymous or correctly named System.register.'); return f.dependencies = l[0], d.importerSetters = [], f.moduleObj = {}, l[2] ? (f.moduleObj.default = f.moduleObj.__useDefault = {}, f.executingRequire = l[1], f.execute = l[2]) : (t = c, r = d, n = f, o = l[1], i = n.moduleObj, a = r.importerSetters, s = !1, u = o.call(w, (e, t) => { if (typeof e === 'object') { let r = !1; for (const n in e)t = e[n], n === '__useDefault' || n in i && i[n] === t || (r = !0, i[n] = t); if (!1 === r) return t; } else { if ((s || e in i) && i[e] === t) return t; i[e] = t; } for (let o = 0; o < a.length; o++)a[o](i); return t; }, new F(t, r.key)), n.setters = u.setters || [], n.execute = u.execute, u.exports && (n.moduleObj = i = u.exports, s = !0)), d; }).catch(e => { throw d.linkRecord = void 0, d.loadError = d.loadError || l(e, `Instantiating ${d.key}`); })); } function K(o, i, e, a, s, u) { return o.resolve(i, e).then(e => { u && (u[i] = e); let t = s.records[e]; const r = a[e]; if (r && (!t || t.module && r !== t.module)) return r; if (t && t.loadError) throw t.loadError; (!t || !r && t.module) && (t = L(s, e, t && t.registration)); const n = t.linkRecord; return n ? A(o, t, n, a, s) : t; }); } function I(e, t, r) { e.loads = e.loads || {}, e.loads[t.key] = { key: t.key, deps: r.dependencies, dynamicDeps: [], depMap: r.depMap || {} }; } function D(e, o, i, t, r) { if (i.depsInstantiatePromise) return i.depsInstantiatePromise; for (var n = Array(i.dependencies.length), a = 0; a < i.dependencies.length; a++)n[a] = K(e, i.dependencies[a], o.key, t, r, e.trace && i.depMap || (i.depMap = {})); let s = Promise.all(n).then(e => { i.dependencyInstantiations = e; if (i.setters) { for (let t = 0; t < e.length; t++) { const r = i.setters[t]; if (r) { const n = e[t]; if (n instanceof j || n[k] === 'module') { r(n); } else { if (n.loadError) throw n.loadError; r(n.module || n.linkRecord.moduleObj); if (n.importerSetters)n.importerSetters.push(r); } } } } return o; }); if (e.trace)s = s.then(() => { I(e, o, i); return o; }); return (s = s.catch(e => { throw i.depsInstantiatePromise = void 0, l(e, `Loading ${o.key}`); })).catch(() => {}), i.depsInstantiatePromise = s; } function F(e, t) { this.loader = e, this.key = this.id = t, this.meta = { url: t }; } function q(e, t) { e.linkRecord = void 0; const r = l(t, `Evaluating ${e.key}`); throw void 0 === e.evalError && (e.evalError = r), r; } function U(e, t, r, n, o, i) { for (var a, s, u = 0; u < r.dependencies.length; u++) { var l; if (!((l = r.dependencyInstantiations[u]) instanceof j || l[k] === 'module') && (a = l.linkRecord)) if (l.evalError)q(t, l.evalError); else if (a.setters) { if (i.indexOf(l) === -1) { i.push(l); try { var c = U(e, l, a, n, o, i); } catch (e) { q(t, e); }c && (s = s || []).push(c.catch(e => { q(t, e); })); } } else try { T(e, l, a, n, o, [l]); } catch (e) { q(t, e); } } if (s) return r.evaluatePromise = Promise.all(s).then(() => { if (r.execute) { try { var e = r.execute.call(z); } catch (e) { q(t, e); } if (e) return e.catch(e => { q(t, e); }).then(() => t.linkRecord = void 0, n[t.key] = t.module = new j(r.moduleObj)); }t.linkRecord = void 0, n[t.key] = t.module = new j(r.moduleObj); }); if (r.execute) { try { var d = r.execute.call(z); } catch (e) { q(t, e); } if (d) return r.evaluatePromise = d.catch(e => { q(t, e); }).then(() => t.linkRecord = void 0, n[t.key] = t.module = new j(r.moduleObj)); }t.linkRecord = void 0, n[t.key] = t.module = new j(r.moduleObj); } function T(e, t, r, n, o, i) { const a = { id: t.key }; const s = r.moduleObj; Object.defineProperty(a, 'exports', { configurable: !0, set(e) { s.default = s.__useDefault = e; }, get() { return s.__useDefault; } }); let u; let l; let c; let d; let f; let p; let g; const h = (u = e, l = t.key, c = r.dependencies, d = r.dependencyInstantiations, f = n, p = o, g = i, function (e) { for (let t = 0; t < c.length; t++) if (c[t] === e) { var r; const n = d[t]; if (n instanceof j || n[k] === 'module')r = n; else { if (n.evalError) throw n.evalError; void 0 !== n.module || g.indexOf(n) !== -1 || n.linkRecord.evaluatePromise || (n.linkRecord.setters ? U(u, n, n.linkRecord, f, p, [n]) : (g.push(n), T(u, n, n.linkRecord, f, p, g))), r = n.module || n.linkRecord.moduleObj; } return '__useDefault' in r ? r.__useDefault : r; } throw new Error(`Module ${e} not declared as a System.registerDynamic dependency of ${l}`); }); if (!r.executingRequire) for (var m = 0; m < r.dependencies.length; m++)h(r.dependencies[m]); try { const v = r.execute.call(w, h, s.default, a); void 0 !== v && (a.exports = v); } catch (e) { q(t, e); }t.linkRecord = void 0, a.exports !== s.__useDefault && (s.default = s.__useDefault = a.exports); const y = s.default; if (y && y.__esModule) for (const b in y)Object.hasOwnProperty.call(y, b) && (s[b] = y[b]); if (n[t.key] = t.module = new j(r.moduleObj), t.importerSetters) for (m = 0; m < t.importerSetters.length; m++)t.importerSetters[m](t.module); t.importerSetters = void 0; }M.prototype[M.resolve = u.resolve] = function (e, t) { return b(e, t || y); }, M.prototype[C] = function (e, t) {}, M.prototype[u.resolveInstantiate] = function (e, t) { const u = this; const l = this[R]; const c = this.registry[E]; return (function (r, e, t, n, o) { let i = n[e]; if (i) return Promise.resolve(i); let a = o.records[e]; return !a || a.module ? r.resolve(e, t).then(e => { if (i = n[e]) return i; if ((a = o.records[e]) && !a.module || (a = L(o, e, a && a.registration)), a.loadError) return Promise.reject(a.loadError); const t = a.linkRecord; return t ? A(r, a, t, n, o) : a; }) : a.loadError ? Promise.reject(a.loadError) : A(r, a, a.linkRecord, n, o); }(u, e, t, c, l)).then(e => { if (e instanceof j || e[k] === 'module') return e; let t; let r; let n; let i; let a; let s; const o = e.linkRecord; if (o) return (t = u, r = e, n = o, i = c, a = l, s = [], (function n(e, o) { return o ? s.indexOf(e) !== -1 ? _ : (s.push(e), D(t, e, o, i, a).then(() => { for (var e, t = 0; t < o.dependencies.length; t++) { const r = o.dependencyInstantiations[t]; r instanceof j || r[k] === 'module' || (e = e || []).push(n(r, r.linkRecord)); } if (e) return Promise.all(e); })) : _; }(r, n))).then(() => (function (e, t, r, n, o) { if (t.module) return t.module; if (t.evalError) throw t.evalError; if (r.evaluatePromise) return r.evaluatePromise; if (r.setters) { const i = U(e, t, r, n, o, [t]); if (i) return i; } else T(e, t, r, n, o, [t]); return t.module; }(u, e, o, c, l))); if (e.module) return e.module; throw e.evalError; }); }, M.prototype.register = function (e, t, r) { const n = this[R]; void 0 === r ? n.lastRegister = [e, t, void 0] : (n.records[e] || L(n, e, void 0)).registration = [t, r, void 0]; }, M.prototype.registerDynamic = function (e, t, r, n) { const o = this[R]; typeof e !== 'string' ? o.lastRegister = [e, t, r] : (o.records[e] || L(o, e, void 0)).registration = [t, r, n]; }, F.prototype.import = function (e) { return this.loader.trace && this.loader.loads[this.key].dynamicDeps.push(e), this.loader.import(e, this.key); }; var z = Object.create(null); Object.freeze && Object.freeze(z); const J = Promise.resolve(); function N() {} const $ = new j({}); let B; const W = e('loader-config'); const G = e('metadata'); const H = typeof window === 'undefined' && typeof self !== 'undefined' && typeof importScripts !== 'undefined'; function Z(e, t) { (t || this.warnings && typeof console !== 'undefined' && console.warn) && console.warn(e); } function X(e, t) { for (const r in t)Object.hasOwnProperty.call(t, r) && (e[r] = t[r]); return e; } function Y(e, t) { for (const r in t)Object.hasOwnProperty.call(t, r) && void 0 === e[r] && (e[r] = t[r]); return e; } function Q(e, t, r) { for (const n in t) if (Object.hasOwnProperty.call(t, n)) { const o = t[n]; void 0 === e[n] ? e[n] = o : o instanceof Array && e[n] instanceof Array ? e[n] = [].concat(r ? o : e[n]).concat(r ? e[n] : o) : typeof o === 'object' && o !== null && typeof e[n] === 'object' ? e[n] = (r ? Y : X)(X({}, e[n]), o) : r || (e[n] = o); } } let V = !1; let ee = !1; function te(e) { if (V || ee) { const t = document.createElement('link'); V ? (t.rel = 'preload', t.as = 'script') : t.rel = 'prefetch', t.href = e, document.head.appendChild(t); } else { (new Image()).src = e; } } if (p && (function () { const e = document.createElement('link').relList; if (e && e.supports) { ee = !0; try { V = e.supports('preload'); } catch (e) {} } }()), p) { const re = window.onerror; window.onerror = function (e, t) { re && re.apply(this, arguments); }; } function ne(t, e, r, n, o) { if (t = t.replace(/#/g, '%23'), H) return (function (e, t, r) { try { importScripts(e); } catch (e) { r(e); }t(); }(t, n, o)); const i = document.createElement('script'); function a() { n(), u(); } function s(e) { u(), o(new Error(`Fetching ${t}`)); } function u() { i.removeEventListener('load', a, !1), i.removeEventListener('error', s, !1), document.head.removeChild(i); }i.type = 'text/javascript', i.charset = 'utf-8', i.async = !0, e && (i.crossOrigin = e), r && (i.integrity = r), i.addEventListener('load', a, !1), i.addEventListener('error', s, !1), i.src = t, document.head.appendChild(i); } function oe(e, t) { for (let r = e.split('.'); r.length;)t = t[r.shift()]; return t; } function ie(e, t, r) { const n = se(t, r); if (n) { const o = t[n] + r.substr(n.length); const i = b(o, y); return void 0 !== i ? i : e + o; } return r.indexOf(':') !== -1 ? r : e + r; } function ae(e) { const t = this.name; if (t.substr(0, e.length) === e && (t.length === e.length || t[e.length] === '/' || e[e.length - 1] === '/' || e[e.length - 1] === ':')) { const r = e.split('/').length; r > this.len && (this.match = e, this.len = r); } } function se(e, t) { if (Object.hasOwnProperty.call(e, t)) return t; const r = { name: t, match: void 0, len: 0 }; return Object.keys(e).forEach(ae, r), r.match; } let ue; const le = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF."'])require\s*\(\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*'|`[^`\\]*(?:\\.[^`\\]*)*`)\s*\)/g; function ce(e, t, r, n) { if (e.substr(0, 8) === 'file:///') { if (fe) return de(e, t, r, n); throw new Error('Unable to fetch file URLs in this environment.'); }e = e.replace(/#/g, '%23'); const o = { headers: { Accept: 'application/x-es-module, */*' } }; return r && (o.integrity = r), t && (typeof t === 'string' && (o.headers.Authorization = t), o.credentials = 'include'), fetch(e, o).then(e => { if (e.ok) return n ? e.arrayBuffer() : e.text(); throw new Error(`Fetch error: ${e.status} ${e.statusText}`); }); } function de(i, a, e, s) { return new Promise(((e, t) => { i = i.replace(/#/g, '%23'); const r = new XMLHttpRequest(); function n() { e(s ? r.response : r.responseText); } function o() { t(new Error(`XHR error: ${r.status ? ` (${r.status}${r.statusText ? ` ${r.statusText}` : ''})` : ''} loading ${i}`)); }s && (r.responseType = 'arraybuffer'), r.onreadystatechange = function () { r.readyState === 4 && (r.status == 0 ? r.response ? n() : (r.addEventListener('error', o), r.addEventListener('load', n)) : r.status === 200 ? n() : o()); }, r.open('GET', i, !0), r.setRequestHeader && (r.setRequestHeader('Accept', 'application/x-es-module, */*'), a && (typeof a === 'string' && r.setRequestHeader('Authorization', a), r.withCredentials = !0)), r.send(null); })); } var fe = typeof XMLHttpRequest !== 'undefined'; const pe = typeof fetch !== 'undefined'; const ge = typeof self !== 'undefined' && void 0 !== self.fetch ? ce : fe ? de : typeof require !== 'undefined' && typeof process !== 'undefined' ? function (e, t, r, i) { return e.substr(0, 8) != 'file:///' ? pe ? ce(e, t, r, i) : Promise.reject(new Error(`Unable to fetch "${e}". Only file URLs of the form file:/// supported running in Node without fetch.`)) : (ue = ue || require('fs'), e = a ? e.replace(/\//g, '\\').substr(8) : e.substr(7), new Promise(((n, o) => { ue.readFile(e, (e, t) => { if (e) return o(e); if (i)n(t); else { let r = `${t}`; r[0] === '\ufeff' && (r = r.substr(1)), n(r); } }); }))); } : function () { throw new Error('No fetch method is defined for this environment.'); }; function he(e, t, r) { let n; const o = { pluginKey: void 0, pluginArgument: void 0, pluginModule: void 0, packageKey: void 0, packageConfig: void 0, load: void 0 }; r && (t.pluginFirst ? (n = r.lastIndexOf('!')) !== -1 && (o.pluginArgument = o.pluginKey = r.substr(0, n)) : (n = r.indexOf('!')) !== -1 && (o.pluginArgument = o.pluginKey = r.substr(n + 1)), o.packageKey = se(t.packages, r), o.packageKey && (o.packageConfig = t.packages[o.packageKey])); return o; } function me(e, t) { const r = ke(e.pluginFirst, t); if (r) { const n = me.call(this, e, r.plugin); return xe(e.pluginFirst, ve.call(this, e, r.argument, void 0, !1, !1), n); } return ve.call(this, e, t, void 0, !1, !1); } function ve(e, t, r, n, o) { let i = b(t, r || y); if (i) return ie(e.baseURL, e.paths, i); if (n) { const a = se(e.map, t); if (a && (i = b(t = e.map[a] + t.substr(a.length), y))) return ie(e.baseURL, e.paths, i); } if (this.registry.has(t)) return t; if (t.substr(0, 6) === '@node/') return t; const s = o && t[t.length - 1] !== '/'; const u = ie(e.baseURL, e.paths, s ? `${t}/` : t); return s ? u.substr(0, u.length - 1) : u; } function ye(e, t, r, n, o, i) { if (o && o.packageConfig && t[0] !== '.') { const a = o.packageConfig.map; const s = a && se(a, t); if (s && typeof a[s] === 'string') { const u = Se(this, e, o.packageConfig, o.packageKey, s, t, n, i); if (u) return u; } } const l = ve.call(this, e, t, r, !0, !0); const c = _e(e, l); if (n.packageKey = c && c.packageKey || se(e.packages, l), !n.packageKey) return l; if (e.packageConfigKeys.indexOf(l) !== -1) return n.packageKey = void 0, l; n.packageConfig = e.packages[n.packageKey] || (e.packages[n.packageKey] = qe()); const d = l.substr(n.packageKey.length + 1); return (function (e, t, r, n, o, i, a) { if (!o) { if (!r.main) return n; o = r.main.substr(0, 2) === './' ? r.main.substr(2) : r.main; } if (r.map) { let s = `./${o}`; let u = se(r.map, s); if (u || (s = `./${Ee(t, r, n, o, a)}`) !== `./${o}` && (u = se(r.map, s)), u) { const l = Se(e, t, r, n, u, s, i, a); if (l) return l; } } return `${n}/${Ee(t, r, n, o, a)}`; }(this, e, n.packageConfig, n.packageKey, d, n, i)); } function be(n, o, i, a, r, s) { const u = this; return J.then(() => { if (r && r.packageConfig && o.substr(0, 2) !== './') { const e = r.packageConfig.map; const t = e && se(e, o); if (t) return je(u, n, r.packageConfig, r.packageKey, t, o, a, s); } return J; }).then(e => { if (e) return e; const t = ve.call(u, n, o, i, !0, !0); const r = _e(n, t); return a.packageKey = r && r.packageKey || se(n.packages, t), a.packageKey ? n.packageConfigKeys.indexOf(t) !== -1 ? (a.packageKey = void 0, a.load = we(), a.load.format = 'json', a.load.loader = '', Promise.resolve(t)) : (a.packageConfig = n.packages[a.packageKey] || (n.packages[a.packageKey] = qe()), (r && !a.packageConfig.configured ? (function (e, t, r, n, o) { const i = e.pluginLoader || e; t.packageConfigKeys.indexOf(r) === -1 && t.packageConfigKeys.push(r); return i.import(r).then(e => { Ue(n.packageConfig, e, n.packageKey, !0, t), n.packageConfig.configured = !0; }).catch(e => { throw l(e, `Unable to fetch package configuration file ${r}`); }); }(u, n, r.configPath, a)) : J).then(() => { const e = t.substr(a.packageKey.length + 1); return (function (e, t, r, n, o, i, a) { if (!o) { if (!r.main) return Promise.resolve(n); o = r.main.substr(0, 2) === './' ? r.main.substr(2) : r.main; } let s; let u; r.map && (s = `./${o}`, (u = se(r.map, s)) || (s = `./${Ee(t, r, n, o, a)}`) !== `./${o}` && (u = se(r.map, s))); return (u ? je(e, t, r, n, u, s, i, a) : J).then(e => (e ? Promise.resolve(e) : Promise.resolve(`${n}/${Ee(t, r, n, o, a)}`))); }(u, n, a.packageConfig, a.packageKey, e, a, s)); })) : Promise.resolve(t); }); } function we() { return { extension: '', deps: void 0, format: void 0, loader: void 0, scriptLoad: void 0, globals: void 0, nonce: void 0, integrity: void 0, sourceMap: void 0, exports: void 0, encapsulateGlobal: !1, crossOrigin: void 0, cjsRequireDetection: !0, cjsDeferDepsExecute: !1, esModule: !1 }; } function ke(e, t) { let r; let n; const o = e ? t.indexOf('!') : t.lastIndexOf('!'); if (o !== -1) return n = e ? (r = t.substr(o + 1), t.substr(0, o)) : (r = t.substr(0, o), t.substr(o + 1) || r.substr(r.lastIndexOf('.') + 1)), { argument: r, plugin: n }; } function xe(e, t, r) { return e ? `${r}!${t}` : `${t}!${r}`; } function Ee(e, t, r, n, o) { if (!n || !t.defaultExtension || n[n.length - 1] === '/' || o) return n; let i = !1; if (t.meta && Re(t.meta, n, (e, t, r) => { if (r === 0 || e.lastIndexOf('*') !== e.length - 1) return i = !0; }), !i && e.meta && Re(e.meta, `${r}/${n}`, (e, t, r) => { if (r === 0 || e.lastIndexOf('*') !== e.length - 1) return i = !0; }), i) return n; const a = `.${t.defaultExtension}`; return n.substr(n.length - a.length) !== a ? n + a : n; } function Oe(e, t, r) { return !(t.substr(0, e.length) === e && r.length > e.length); } function Se(e, t, r, n, o, i, a, s) { i[i.length - 1] === '/' && (i = i.substr(0, i.length - 1)); const u = r.map[o]; if (typeof u === 'object') throw new Error(`Synchronous conditional normalization not supported sync normalizing ${o} in ${n}`); if (Oe(o, u, i) && typeof u === 'string') return ye.call(e, t, u + i.substr(o.length), `${n}/`, a, a, s); } function je(t, r, e, n, o, i, a, s) { i[i.length - 1] === '/' && (i = i.substr(0, i.length - 1)); const u = e.map[o]; if (typeof u === 'string') return Oe(o, u, i) ? be.call(t, r, u + i.substr(o.length), `${n}/`, a, a, s).then(e => Ke.call(t, e, `${n}/`, a)) : J; const l = []; const c = []; for (const d in u) { const f = Ce(d); c.push({ condition: f, map: u[d] }), l.push(M.prototype.import.call(t, f.module, n)); } return Promise.all(l).then(e => { for (let t = 0; t < c.length; t++) { const r = c[t].condition; const n = oe(r.prop, '__useDefault' in e[t] ? e[t].__useDefault : e[t]); if (!r.negate && n || r.negate && !n) return c[t].map; } }).then(e => { if (e) return Oe(o, e, i) ? be.call(t, r, e + i.substr(o.length), `${n}/`, a, a, s).then(e => Ke.call(t, e, `${n}/`, a)) : J; }); } const Pe = {}; function _e(e, t) { for (var r, n, o, i, a, s = !1, u = 0; u < e.packageConfigPaths.length; u++) { const l = e.packageConfigPaths[u]; const c = Pe[l] || (Pe[l] = (void 0, i = (o = l).lastIndexOf('*'), { length: a = Math.max(i + 1, o.lastIndexOf('/')), regEx: new RegExp(`^(${o.substr(0, a).replace(/[.+?^${}()|[\]\\]/g, '\\$&').replace(/\*/g, '[^\\/]+')})(\\/|$)`), wildcard: i !== -1 })); if (!(t.length < c.length)) { const d = t.match(c.regEx); !d || r && (s && c.wildcard || !(r.length < d[1].length)) || (r = d[1], s = !c.wildcard, n = r + l.substr(c.length)); } } if (r) return { packageKey: r, configPath: n }; } function Re(e, t, r) { let n; for (let o in e) { const i = o.substr(0, 2) === './' ? './' : ''; if (i && (o = o.substr(2)), (n = o.indexOf('*')) !== -1 && o.substr(0, n) === t.substr(0, n) && o.substr(n + 1) === t.substr(t.length - o.length + n + 1) && r(o, e[i + o], o.split('/').length)) return; } const a = e[t] && Object.hasOwnProperty.call(e, t) ? e[t] : e[`./${t}`]; a && r(a, a, 0); } const Me = ['browser', 'node', 'dev', 'build', 'production', 'default']; function Ce(e) { let t; let r; let n; const o = e.lastIndexOf('|'); return o !== -1 ? (t = e.substr(o + 1), r = e.substr(0, o), t[0] === '~' && (n = !0, t = t.substr(1))) : (n = e[0] === '~', t = 'default', r = e.substr(n), Me.indexOf(r) !== -1 && (t = r, r = null)), { module: r || '@system-env', prop: t, negate: n }; } function Le(r, e, n) { return M.prototype.import.call(this, r.module, e).then(e => { const t = oe(r.prop, e); if (n && typeof t !== 'boolean') throw new TypeError('Condition did not resolve to a boolean.'); return r.negate ? !t : t; }); } const Ae = /#\{[^\}]+\}/; function Ke(t, r, e) { const n = t.match(Ae); if (!n) return Promise.resolve(t); const o = Ce.call(this, n[0].substr(2, n[0].length - 3)); return Le.call(this, o, r, !1).then(e => { if (typeof e !== 'string') throw new TypeError(`The condition value for ${t} doesn't resolve to a string.`); if (e.indexOf('/') !== -1) throw new TypeError(`Unabled to interpolate conditional ${t}${r ? ` in ${r}` : ''}\n\tThe condition value ${e} cannot contain a "/" separator.`); return t.replace(Ae, e); }); } const Ie = ['browserConfig', 'nodeConfig', 'devConfig', 'buildConfig', 'productionConfig']; function De(e, t, r) { for (let n = 0; n < Ie.length; n++) { const o = Ie[n]; t[o] && At[o.substr(0, o.length - 6)] && r(t[o]); } } function Fe(e, t) { const r = e[t]; return r instanceof Array ? e[t].concat([]) : typeof r === 'object' ? (function e(t, r) { const n = {}; for (const o in t) { const i = t[o]; r > 1 ? i instanceof Array ? n[o] = [].concat(i) : typeof i === 'object' ? n[o] = e(i, r - 1) : o !== 'packageConfig' && (n[o] = i) : n[o] = i; } return n; }(r, 3)) : e[t]; } function qe() { return { defaultExtension: void 0, main: void 0, format: void 0, meta: void 0, map: void 0, packageConfig: void 0, configured: !1 }; } function Ue(e, t, r, n, o) { for (const i in t)i === 'main' || i === 'format' || i === 'defaultExtension' || i === 'configured' ? n && void 0 !== e[i] || (e[i] = t[i]) : i === 'map' ? (n ? Y : X)(e.map = e.map || {}, t.map) : i === 'meta' ? (n ? Y : X)(e.meta = e.meta || {}, t.meta) : Object.hasOwnProperty.call(t, i) && Z.call(o, `"${i}" is not a valid package configuration option in package ${r}`); return void 0 === e.defaultExtension && (e.defaultExtension = 'js'), void 0 === e.main && e.map && e.map['.'] ? (e.main = e.map['.'], delete e.map['.']) : typeof e.main === 'object' && (e.map = e.map || {}, e.map['./@main'] = e.main, e.main.default = e.main.default || './', e.main = '@main'), e; } let Te = typeof Buffer !== 'undefined'; try { Te && new Buffer('a').toString('base64') !== 'YQ==' && (Te = !1); } catch (e) { Te = !1; } let ze; let Je; let Ne; let $e; const Be = '\n//# sourceMappingURL=data:application/json;base64,'; function We(e, t, r, n) { let o; const i = e.lastIndexOf('\n'); if (t) { if (typeof t !== 'object') throw new TypeError('load.metadata.sourceMap must be set to an object.'); t = JSON.stringify(t); } return (n ? '(function(System, SystemJS) {' : '') + e + (n ? '\n})(System, System);' : '') + (e.substr(i, 15) != '\n//# sourceURL=' ? `\n//# sourceURL=${r}${t ? '!transpiled' : ''}` : '') + (t && (o = t, Te ? Be + new Buffer(o).toString('base64') : typeof btoa !== 'undefined' ? Be + btoa(unescape(encodeURIComponent(o))) : '') || ''); } let Ge = 0; function He(e) { Ge++ == 0 && ($e = w.System), w.System = w.SystemJS = e; } function Ze() { --Ge == 0 && (w.System = w.SystemJS = $e); } let Xe; let Ye = !1; function Qe(e, t, r, n, o, i, a) { if (t) { if (i && Ye) return (function (e, t, r, n, o) { ze || (ze = document.head || document.body || document.documentElement); const i = document.createElement('script'); i.text = We(t, r, n, !1); let a; const s = window.onerror; if (window.onerror = function (e) { a = addToError(e, `Evaluating ${n}`), s && s.apply(this, arguments); }, He(e), o && i.setAttribute('nonce', o), ze.appendChild(i), ze.removeChild(i), Ze(), window.onerror = s, a) return a; }(e, t, r, n, i)); try { He(e), !Je && e._nodeRequire && (Je = e._nodeRequire('vm'), Ne = Je.runInThisContext('typeof System !== \'undefined\' && System') === e), Ne ? Je.runInThisContext(We(t, r, n, !a), { filename: n + (r ? '!transpiled' : '') }) : (0, eval)(We(t, r, n, !a)), Ze(); } catch (e) { return Ze(), e; } } } function Ve(p) { function g(e, t, r, n) { if (typeof e === 'object' && !(e instanceof Array)) return g.apply(null, Array.prototype.splice.call(arguments, 1, arguments.length - 1)); if (typeof e === 'string' && typeof t === 'function' && (e = [e]), !(e instanceof Array)) { if (typeof e !== 'string') throw new TypeError('Invalid require'); const o = p.decanonicalize(e, n); const i = p.get(o); if (!i) throw new Error(`Module not already loaded loading "${e}" as ${o}${n ? ` from "${n}".` : '.'}`); return '__useDefault' in i ? i.__useDefault : i; } for (var a = [], s = 0; s < e.length; s++)a.push(p.import(e[s], n)); Promise.all(a).then(e => { t && t.apply(null, e); }, r); } function e(e, u, l) { let t; let c; let d; let f; function r(n, e, o) { for (var t = [], r = 0; r < u.length; r++)t.push(n(u[r])); if (o.uri = o.id, o.config = N, f !== -1 && t.splice(f, 0, o), d !== -1 && t.splice(d, 0, e), c !== -1) { const i = function (e, t, r) { return typeof e === 'string' && typeof t !== 'function' ? n(e) : g.call(p, e, t, r, o.id); }; i.toUrl = function (e) { return p.normalizeSync(e, o.id); }, t.splice(c, 0, i); } const a = w.require; w.require = g; const s = l.apply(d === -1 ? w : e, t); w.require = a, void 0 !== s && (o.exports = s); } typeof e !== 'string' && (l = u, u = e, e = null), u instanceof Array || (u = ['require', 'exports', 'module'].splice(0, (l = u).length)), typeof l !== 'function' && (t = l, l = function () { return t; }), e || vt && (u = u.concat(vt), vt = void 0), (c = u.indexOf('require')) !== -1 && (u.splice(c, 1), e || (u = u.concat(function (e, t) { const r = ((e = e.replace(nt, '')).match(ft)[1].split(',')[t] || 'require').replace(pt, ''); const n = gt[r] || (gt[r] = new RegExp(ct + r + dt, 'g')); n.lastIndex = 0; let o; const i = []; for (;o = n.exec(e);)i.push(o[2] || o[3]); return i; }(l.toString(), c)))), (d = u.indexOf('exports')) !== -1 && u.splice(d, 1), (f = u.indexOf('module')) !== -1 && u.splice(f, 1), e ? (p.registerDynamic(e, u, !1, r), mt ? yt = !(mt = void 0) : yt || (mt = [u, r])) : p.registerDynamic(u, !1, bt ? ht(r) : r); }e.amd = {}, p.amdDefine = e, p.amdRequire = g; } function et(e) { return e.substr(0, 8) === 'file:///' ? e.substr(7 + !!a) : Xe && e.substr(0, Xe.length) === Xe ? e.substr(Xe.length) : e; } function tt(e, t) { return et(this.normalizeSync(e, t)); } function rt(e) { let t; const r = e.lastIndexOf('!'); let n = (t = r !== -1 ? e.substr(0, r) : e).split('/'); return n.pop(), n = n.join('/'), { filename: et(t), dirname: et(n) }; }p && typeof document !== 'undefined' && document.getElementsByTagName && (window.chrome && window.chrome.extension || navigator.userAgent.match(/^Node\.js/) || (Ye = !0)), typeof window !== 'undefined' && typeof document !== 'undefined' && window.location && (Xe = `${location.protocol}//${location.hostname}${location.port ? `:${location.port}` : ''}`); var nt = /(^|[^\\])(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm; const ot = /("[^"\\\n\r]*(\\.[^"\\\n\r]*)*"|'[^'\\\n\r]*(\\.[^'\\\n\r]*)*')/g; let it; const at = ['_g', 'sessionStorage', 'localStorage', 'clipboardData', 'frames', 'frameElement', 'external', 'mozAnimationStartTime', 'mozPaintCount', 'webkitStorageInfo', 'webkitIndexedDB', 'mozInnerScreenY', 'mozInnerScreenX']; function st(t) { if (at.indexOf(t) === -1) { try { var e = w[t]; } catch (e) { at.push(t); } this(t, e); } } function ut(e) { if (typeof e === 'string') return oe(e, w); if (!(e instanceof Array)) throw new Error('Global exports must be a string or array.'); for (var t = {}, r = 0; r < e.length; r++)t[e[r].split('.').pop()] = oe(e[r], w); return t; } function lt(e, i, t, a) { let s; const u = w.define; if (w.define = void 0, t) for (const r in s = {}, t)s[r] = w[r], w[r] = t[r]; return i || (it = {}, Object.keys(w).forEach(st, (e, t) => { it[e] = t; })), function () { let r; let n = i ? ut(i) : {}; let o = !!i; if (i && !a || Object.keys(w).forEach(st, (e, t) => { it[e] !== t && void 0 !== t && (a && (w[e] = void 0), i || (n[e] = t, void 0 !== r ? o || r === t || (o = !0) : r = t)); }), n = o ? n : r, s) for (const e in s)w[e] = s[e]; return w.define = u, n; }; } var ct = '(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])'; var dt = '\\s*\\(\\s*("([^"]+)"|\'([^\']+)\')\\s*\\)'; var ft = /\(([^\)]*)\)/; var pt = /^\s+|\s+$/g; var gt = {}; function ht(n) { return function (e, t, r) { n(e, t, r), typeof (t = r.exports) !== 'object' && typeof t !== 'function' || '__esModule' in t || Object.defineProperty(r.exports, '__esModule', { value: !0 }); }; } let mt; let vt; var yt = !1; var bt = !1; let wt; const kt = (p || H) && typeof navigator !== 'undefined' && navigator.userAgent && !navigator.userAgent.match(/MSIE (9|10).0/); function xt(e, t) { !e.load.esModule || typeof t !== 'object' && typeof t !== 'function' || '__esModule' in t || Object.defineProperty(t, '__esModule', { value: !0 }); } function Et(p, g, e, h, m) {
        return Promise.resolve(e).then(e => h.load.format === 'detect' && (h.load.format = void 0), (function (e, t) { const r = e.match(Kt); if (!r) return; for (let n = r[0].match(It), o = 0; o < n.length; o++) { const i = n[o]; let a = i.length; const s = i.substr(0, 1); if (i.substr(a - 1, 1) == ';' && a--, s == '"' || s == '\'') { const u = i.substr(1, i.length - 3); let l = u.substr(0, u.indexOf(' ')); if (l) { const c = u.substr(l.length + 1, u.length - l.length - 1); l === 'deps' && (l = 'deps[]'), l.substr(l.length - 2, 2) === '[]' ? (l = l.substr(0, l.length - 2), t.load[l] = t.load[l] || [], t.load[l].push(c)) : l !== 'use' && Dt(t.load, l, c); } else t.load[u] = !0; } } }(e, h)), h.pluginModule ? (h.pluginLoad.source = e, h.pluginModule.translate ? Promise.resolve(h.pluginModule.translate.call(p, h.pluginLoad, h.traceOpts)).then(e => { if (h.load.sourceMap) { if (typeof h.load.sourceMap !== 'object') throw new Error('metadata.load.sourceMap must be set to an object.'); Ct(h.pluginLoad.address, h.load.sourceMap); } return typeof e === 'string' ? e : h.pluginLoad.source; }) : e) : e).then(e => (h.load.format || e.substring(0, 8) !== '"bundle"' ? h.load.format === 'register' || !h.load.format && Pt(e) ? (h.load.format = 'register', e) : h.load.format === 'esm' || !h.load.format && e.match(St) ? (h.load.format = 'esm', (function (t, r, n, o, e) { if (!t.transpiler) throw new TypeError('Unable to dynamically transpile ES module\n   A loader plugin needs to be configured via `SystemJS.config({ transpiler: \'transpiler-module\' })`.'); if (o.load.deps) { for (var i = '', a = 0; a < o.load.deps.length; a++)i += `import "${o.load.deps[a]}"; `; r = i + r; } return t.import.call(t, t.transpiler).then(e => { if (!(e = e.__useDefault || e).translate) throw new Error(`${t.transpiler} is not a valid transpiler plugin.`); return e === o.pluginModule ? r : (typeof o.load.sourceMap === 'string' && (o.load.sourceMap = JSON.parse(o.load.sourceMap)), o.pluginLoad = o.pluginLoad || { name: n, address: n, source: r, metadata: o.load }, o.load.deps = o.load.deps || [], Promise.resolve(e.translate.call(t, o.pluginLoad, o.traceOpts)).then(e => { const t = o.load.sourceMap; return t && typeof t==='object' && Ct(n, t), o.load.format === 'esm' && Pt(e) && (o.load.format = 'register'), e; })); }, e => { throw l(e, `Unable to load transpiler to transpile ${n}`); }); }(p, e, g, h))) : e : (h.load.format = 'system', e))).then(t => { if (typeof t !== 'string' || !h.pluginModule || !h.pluginModule.instantiate) return t; let r = !1; return h.pluginLoad.source = t, Promise.resolve(h.pluginModule.instantiate.call(p, h.pluginLoad, e => { if (t = e.source, h.load = e.metadata, r) throw new Error('Instantiate must only be called once.'); r = !0; })).then(e => (r ? t : (function (e) { if (e) { if (e instanceof j || e[k] === 'module') return e; if (e.__esModule) return new j(e); } return new j({ default: e, __useDefault: e }); }(e)))); })
            .then(c => { if (typeof c !== 'string') return c; let e; h.load.format || (h.load.format = (e = c).match(_t) ? 'amd' : (Rt.lastIndex = 0, le.lastIndex = 0, le.exec(e) || Rt.exec(e) ? 'cjs' : 'global')); let t; let r; let n; let o = !1; switch (h.load.format) { case 'esm': case 'register': case 'system': if (s = Qe(p, c, h.load.sourceMap, g, h.load.integrity, h.load.nonce, !1)) throw s; return m() ? void 0 : $; case 'json': var i = JSON.parse(c); return p.newModule({ default: i, __useDefault: i }); case 'amd': var a = w.define; w.define = p.amdDefine, r = h.load.deps, n = h.load.esModule, vt = r, bt = n, mt = void 0, yt = !1; var s = Qe(p, c, h.load.sourceMap, g, h.load.integrity, h.load.nonce, !1); if ((o = m()) || (t = p, mt ? t.registerDynamic(vt ? mt[0].concat(vt) : mt[0], !1, bt ? ht(mt[1]) : mt[1]) : yt && t.registerDynamic([], !1, N), o = m()), w.define = a, s) throw s; break; case 'cjs': var d = h.load.deps; var u = (h.load.deps || []).concat(h.load.cjsRequireDetection ? (function (e) { le.lastIndex = nt.lastIndex = ot.lastIndex = 0; let t; const r = []; const n = []; const o = []; function i(e, t) { for (let r = 0; r < e.length; r++) if (e[r][0] < t.index && e[r][1] > t.index) return !0; return !1; } if (e.length / e.split('\n').length < 200) { for (;t = ot.exec(e);)n.push([t.index, t.index + t[0].length]); for (;t = nt.exec(e);)i(n, t) || o.push([t.index + t[1].length, t.index + t[0].length - 1]); } for (;t = le.exec(e);) if (!i(n, t) && !i(o, t)) { const a = t[1].substr(1, t[1].length - 2); if (a.match(/"|'/)) continue; r.push(a); } return r; }(c)) : []); for (var l in h.load.globals)h.load.globals[l] && u.push(h.load.globals[l]); p.registerDynamic(u, !0, (e, t, r) => { if (e.resolve = function (e) { return tt.call(p, e, r.id); }, r.paths = [], r.require = e, !h.load.cjsDeferDepsExecute && d) for (let n = 0; n < d.length; n++)e(d[n]); const o = rt(r.id); const i = { exports: t, args: [e, t, r, o.filename, o.dirname, w, w] }; let a = '(function (require, exports, module, __filename, __dirname, global, GLOBAL'; if (h.load.globals) for (const s in h.load.globals)i.args.push(e(h.load.globals[s])), a += `, ${s}`; const u = w.define; w.define = void 0, w.__cjsWrapper = i, c = `${a}) {${c.replace(Mt, '')}\n}).apply(__cjsWrapper.exports, __cjsWrapper.args);`; const l = Qe(p, c, h.load.sourceMap, g, h.load.integrity, h.load.nonce, !1); if (l) throw l; xt(h, t), w.__cjsWrapper = void 0, w.define = u; }), o = m(); break; case 'global': u = h.load.deps || []; for (var l in h.load.globals) { const f = h.load.globals[l]; f && u.push(f); }p.registerDynamic(u, !1, (e, t, r) => { let n; if (h.load.globals) for (const o in n = {}, h.load.globals)h.load.globals[o] && (n[o] = e(h.load.globals[o])); const i = h.load.exports; i && (c += `\n${Ot}["${i}"] = ${i};`); const a = lt(r.id, i, n, h.load.encapsulateGlobal); const s = Qe(p, c, h.load.sourceMap, g, h.load.integrity, h.load.nonce, !0); if (s) throw s; const u = a(); return xt(h, u), u; }), o = m(); break; default: throw new TypeError(`Unknown module format "${h.load.format}" for "${g}".${h.load.format === 'es6' ? ' Use "esm" instead here.' : ''}`); } if (!o) throw new Error(`Module ${g} detected as ${h.load.format} but didn't execute correctly.`); }); 
    } typeof require === 'undefined' || typeof process === 'undefined' || process.browser || (wt = require); var Ot = typeof self !== 'undefined' ? 'self' : 'global'; var St = /(^\s*|[}\);\n]\s*)(import\s*(['"]|(\*\s+as\s+)?(?!type)([^"'\(\)\n; ]+)\s*from\s*['"]|\{)|export\s+\*\s+from\s+["']|export\s*(\{|default|function|class|var|const|let|async\s+function))/; const 
        jt = /^(\s*\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)*\s*/; function Pt(e) { const t = e.match(jt); if (!t) return !1; const r = t[0].length; return e.substr(r, 17) === 'SystemJS.register' || e.substr(r, 15) === 'System.register'; } var _t = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])define\s*\(\s*("[^"]+"\s*,\s*|'[^']+'\s*,\s*)?\s*(\[(\s*(("[^"]+"|'[^']+')\s*,|\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*(\s*("[^"]+"|'[^']+')\s*,?)?(\s*(\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*\s*\]|function\s*|{|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*\))/; var Rt = /(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])(exports\s*(\[['"]|\.)|module(\.exports|\['exports'\]|\["exports"\])\s*(\[['"]|[=,\.]))/; var Mt = /^\#\!.*/; function Ct(e, t) { const r = e.split('!')[0]; t.file && t.file != e || (t.file = `${r}!transpiled`), (!t.sources || t.sources.length <= 1 && (!t.sources[0] || t.sources[0] === e)) && (t.sources = [r]); } let Lt; let At; var Kt = /^(\s*\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)+/; var It = /\/\*[^\*]*(\*(?!\/)[^\*]*)*\*\/|\/\/[^\n]*|"[^"]+"\s*;?|'[^']+'\s*;?/g; function Dt(e, t, r) { for (var n, o = t.split('.'); o.length > 1;)e = e[n = o.shift()] = e[n] || {}; void 0 === e[n = o.shift()] && (e[n] = r); } if (typeof Promise === 'undefined') throw new Error('SystemJS needs a Promise polyfill.'); if (typeof document !== 'undefined') { const Ft = document.getElementsByTagName('script'); let qt = Ft[Ft.length - 1]; document.currentScript && (qt.defer || qt.async) && (qt = document.currentScript), Lt = qt && qt.src; } else if (typeof importScripts !== 'undefined') try { throw new Error('_'); } catch (e) { e.stack.replace(/(?:at|@).*(http.+):[\d]+:[\d]+/, (e, t) => { Lt = t; }); } else typeof __filename !== 'undefined' && (Lt = __filename); function Ut() { let e; M.call(this), this._loader = {}, this[G] = {}, this[W] = { baseURL: y, paths: {}, packageConfigPaths: [], packageConfigKeys: [], map: {}, packages: {}, depCache: {}, meta: {}, bundles: {}, production: !1, transpiler: void 0, loadedBundles: {}, warnings: !1, pluginFirst: !1, wasm: !1 }, this.scriptSrc = Lt, this._nodeRequire = wt, this.registry.set('@empty', $), Tt.call(this, !1, !1), (e = this).set('@@cjs-helpers', e.newModule({ requireResolve: tt.bind(e), getPathVars: rt })), e.set('@@global-helpers', e.newModule({ prepareGlobal: lt })), Ve(this); } function Tt(e, t) { this[W].production = e, this.registry.set('@system-env', At = this.newModule({ browser: p, node: !!this._nodeRequire, production: !t && e, dev: t || !e, build: t, default: !0 })); }((Ut.prototype = Object.create(M.prototype)).constructor = Ut).prototype[Ut.resolve = M.resolve] = Ut.prototype.normalize = function (r, n) {
        const o = this[W]; const i = { pluginKey: void 0, pluginArgument: void 0, pluginModule: void 0, packageKey: void 0, packageConfig: void 0, load: void 0 }; const a = he(0, o, n); const s = this; return Promise.resolve().then(() => { const t = r.lastIndexOf('#?'); if (t === -1) return Promise.resolve(r); const e = Ce.call(s, r.substr(t + 2)); return Le.call(s, e, n, !0).then(e => (e ? r.substr(0, t) : '@empty')); }).then(e => { const t = ke(o.pluginFirst, e); return t ? (i.pluginKey = t.plugin, Promise.all([be.call(s, o, t.argument, a && a.pluginArgument || n, i, a, !0), s.resolve(t.plugin, n)]).then(e => { if (i.pluginArgument = e[0], i.pluginKey = e[1], i.pluginArgument === i.pluginKey) throw new Error(`Plugin ${i.pluginArgument} cannot load itself, make sure it is excluded from any wildcard meta configuration via a custom loader: false rule.`); return xe(o.pluginFirst, e[0], e[1]); })) : be.call(s, o, e, a && a.pluginArgument || n, i, a, !1); }).then(e => Ke.call(s, e, n, a))
            .then(t => function (e, t, r) { r.load = r.load || { extension: '', deps: void 0, format: void 0, loader: void 0, scriptLoad: void 0, globals: void 0, nonce: void 0, integrity: void 0, sourceMap: void 0, exports: void 0, encapsulateGlobal: !1, crossOrigin: void 0, cjsRequireDetection: !0, cjsDeferDepsExecute: !1, esModule: !1 }; let n; var o = 0; for (const i in e.meta) if ((n = i.indexOf('*')) !== -1 && i.substr(0, n) === t.substr(0, n) && i.substr(n + 1) === t.substr(t.length - i.length + n + 1)) { const a = i.split('/').length; o < a && (o = a), Q(r.load, e.meta[i], o !== a); } if (e.meta[t] && Q(r.load, e.meta[t], !1), r.packageKey) { const s = t.substr(r.packageKey.length + 1); const u = {}; if (r.packageConfig.meta) { var o = 0; Re(r.packageConfig.meta, s, (e, t, r) => { o < r && (o = r), Q(u, t, r && r < o); }), Q(r.load, u, !1); }!r.packageConfig.format || r.pluginKey || r.load.loader || (r.load.format = r.load.format || r.packageConfig.format); } }.call(s, o, t, i), i.pluginKey || !i.load.loader ? t : s.resolve(i.load.loader, t).then(e => i.pluginKey = e, i.pluginArgument = t))
            .then(e => s[G][e] = i, e); 
    }, Ut.prototype.load = function (e, t) { return Z.call(this[W], 'System.load is deprecated.'), this.import(e, t); }, Ut.prototype.decanonicalize = Ut.prototype.normalizeSync = Ut.prototype.resolveSync = function e(t, r) { const n = this[W]; const o = { pluginKey: void 0, pluginArgument: void 0, pluginModule: void 0, packageKey: void 0, packageConfig: void 0, load: void 0 }; var i = i || he(0, n, r); const a = ke(n.pluginFirst, t); return a ? (o.pluginKey = e.call(this, a.plugin, r), xe(n.pluginFirst, ye.call(this, n, a.argument, i.pluginArgument || r, o, i, !!o.pluginKey), o.pluginKey)) : ye.call(this, n, t, i.pluginArgument || r, o, i, !!o.pluginKey); }, Ut.prototype[Ut.instantiate = M.instantiate] = function (i, c) { const d = this; const f = this[W]; return ((function (e, t, r) { let n; if (p && (n = e.depCache[r])) for (var o = 0; o < n.length; o++)t.normalize(n[o], r).then(te); else { let i = !1; for (const a in e.bundles) { for (var o = 0; o < e.bundles[a].length; o++) { const s = e.bundles[a][o]; if (s === r) { i = !0; break; } if (s.indexOf('*') !== -1) { const u = s.split('*'); if (u.length !== 2) { e.bundles[a].splice(o--, 1); continue; } if (r.substr(0, u[0].length) === u[0] && r.substr(r.length - u[1].length, u[1].length) === u[1]) { i = !0; break; } } } if (i) return t.import(a); } } }(f, this, i)) || J).then(() => { if (!c()) { let e; let t; let r; const n = d[G][i]; if (i.substr(0, 6) !== '@node/') return n.load.scriptLoad ? !n.pluginKey && kt || (n.load.scriptLoad = !1, Z.call(f, `scriptLoad not supported for "${i}"`)) : !1 !== n.load.scriptLoad && !n.pluginKey && kt && (n.load.deps || n.load.globals || !(n.load.format === 'system' || n.load.format === 'register' || n.load.format === 'global' && n.load.exports) || (n.load.scriptLoad = !0)), n.load.scriptLoad ? new Promise(((t, e) => { if (n.load.format === 'amd' && w.define !== d.amdDefine) throw new Error(`Loading AMD with scriptLoad requires setting the global \`${Ot}.define = SystemJS.amdDefine\``); ne(i, n.load.crossOrigin, n.load.integrity, () => { if (!c()) { n.load.format = 'global'; const e = n.load.exports && ut(n.load.exports); d.registerDynamic([], !1, () => xt(n, e), e), c(); }t(); }, e); })) : (e = d, t = i, r = n, r.pluginKey ? e.import(r.pluginKey).then(e => { r.pluginModule = e, r.pluginLoad = { name: t, address: r.pluginArgument, source: void 0, metadata: r.load }, r.load.deps = r.load.deps || []; }) : J).then(() => { return o = d, a = i, s = n, u = c, l = f.wasm, s.load.exports && !s.load.format && (s.load.format = 'global'), J.then(() => { if (s.pluginModule && s.pluginModule.locate) return Promise.resolve(s.pluginModule.locate.call(o, s.pluginLoad)).then(e => { e && (s.pluginLoad.address = e); }); }).then(() => (s.pluginModule ? (l = !1, s.pluginModule.fetch ? s.pluginModule.fetch.call(o, s.pluginLoad, e => ge(e.address, s.load.authorization, s.load.integrity, !1)) : ge(s.pluginLoad.address, s.load.authorization, s.load.integrity, !1)) : ge(a, s.load.authorization, s.load.integrity, l))).then(r => { return l && typeof r !== 'string' ? (e = o, t = r, i = u, n = new Uint8Array(t), n[0] === 0 && n[1] === 97 && n[2] === 115 ? WebAssembly.compile(t).then(t => { const r = []; const n = []; const o = {}; return WebAssembly.Module.imports && WebAssembly.Module.imports(t).forEach(e => { const t = e.module; n.push(e => { o[t] = e; }), r.indexOf(t) === -1 && r.push(t); }), e.register(r, e => ({ setters: n, execute() { e(new WebAssembly.Instance(t, o).exports); } })), i(), !0; }) : Promise.resolve(!1)).then(e => { if (!e) { const t = p ? new TextDecoder('utf-8').decode(new Uint8Array(r)) : r.toString(); return Et(o, a, t, s, u); } }) : Et(o, a, r, s, u); let e; let t; let i; let n; }); let o; let a; let s; let u; let l; }); if (!d._nodeRequire) throw new TypeError(`Error loading ${i}. Can only load node core modules in Node.`); return d.registerDynamic([], !1, () => function (e, t) { if (e[0] === '.') throw new Error(`Node module ${e} can't be loaded as it is not a package require.`); if (!B) { const r = this._nodeRequire('module'); const n = decodeURI(t.substr(a ? 8 : 7)); (B = new r(n)).paths = r._nodeModulePaths(n); } return B.require(e); }.call(d, i.substr(6), d.baseURL)), void c(); } }).then(e => delete d[G][i], e); }, Ut.prototype.config = function (e, t) { let r; const n = this; const o = this[W]; if ('warnings' in e && (o.warnings = e.warnings), 'wasm' in e && (o.wasm = typeof WebAssembly !== 'undefined' && e.wasm), ('production' in e || 'build' in e) && Tt.call(n, !!e.production, !!(e.build || At && At.build)), !t) for (var i in De(0, e, e => { r = r || e.baseURL; }), (r = r || e.baseURL) && (o.baseURL = b(r, y) || b(`./${r}`, y), o.baseURL[o.baseURL.length - 1] !== '/' && (o.baseURL += '/')), e.paths && X(o.paths, e.paths), De(0, e, e => { e.paths && X(o.paths, e.paths); }), o.paths)o.paths[i].indexOf('*') !== -1 && (Z.call(o, `Path config ${i} -> ${o.paths[i]} is no longer supported as wildcards are deprecated.`), delete o.paths[i]); if (e.defaultJSExtensions && Z.call(o, 'The defaultJSExtensions configuration option is deprecated.\n  Use packages defaultExtension instead.', !0), typeof e.pluginFirst === 'boolean' && (o.pluginFirst = e.pluginFirst), e.map) for (var i in e.map) { const a = e.map[i]; if (typeof a === 'string') { let s = ve.call(n, o, a, void 0, !1, !1); s[s.length - 1] === '/' && i[i.length - 1] !== ':' && i[i.length - 1] !== '/' && (s = s.substr(0, s.length - 1)), o.map[i] = s; } else { h = (h = ve.call(n, o, i[i.length - 1] !== '/' ? `${i}/` : i, void 0, !0, !0)).substr(0, h.length - 1); let u = o.packages[h]; u || ((u = o.packages[h] = { defaultExtension: void 0, main: void 0, format: void 0, meta: void 0, map: void 0, packageConfig: void 0, configured: !1 }).defaultExtension = ''), Ue(u, { map: a }, h, !1, o); } } if (e.packageConfigPaths) { for (var l = [], c = 0; c < e.packageConfigPaths.length; c++) { const d = e.packageConfigPaths[c]; const f = Math.max(d.lastIndexOf('*') + 1, d.lastIndexOf('/')); const p = ve.call(n, o, d.substr(0, f), void 0, !1, !1); l[c] = p + d.substr(f); }o.packageConfigPaths = l; } if (e.bundles) for (var i in e.bundles) { const g = []; for (c = 0; c < e.bundles[i].length; c++)g.push(n.normalizeSync(e.bundles[i][c])); o.bundles[i] = g; } if (e.packages) for (var i in e.packages) { if (i.match(/^([^\/]+:)?\/\/$/)) throw new TypeError(`"${i}" is not a valid package name.`); var h; h = (h = ve.call(n, o, i[i.length - 1] !== '/' ? `${i}/` : i, void 0, !0, !0)).substr(0, h.length - 1), Ue(o.packages[h] = o.packages[h] || { defaultExtension: void 0, main: void 0, format: void 0, meta: void 0, map: void 0, packageConfig: void 0, configured: !1 }, e.packages[i], h, !1, o); } if (e.depCache) for (var i in e.depCache)o.depCache[n.normalizeSync(i)] = [].concat(e.depCache[i]); if (e.meta) for (var i in e.meta) if (i[0] === '*')X(o.meta[i] = o.meta[i] || {}, e.meta[i]); else { const m = ve.call(n, o, i, void 0, !0, !0); X(o.meta[m] = o.meta[m] || {}, e.meta[i]); } for (const v in 'transpiler' in e && (o.transpiler = e.transpiler), e)zt.indexOf(v) === -1 && Ie.indexOf(v) === -1 && (n[v] = e[v]); De(0, e, e => { n.config(e, !0); }); }, Ut.prototype.getConfig = function (e) { if (e) { if (zt.indexOf(e) !== -1) return Fe(this[W], e); throw new Error(`"${e}" is not a valid configuration name. Must be one of ${zt.join(', ')}.`); } for (var t = {}, r = 0; r < zt.length; r++) { const n = zt[r]; const o = Fe(this[W], n); void 0 !== o && (t[n] = o); } return t; }, Ut.prototype.global = w, Ut.prototype.import = function () { return M.prototype.import.apply(this, arguments).then(e => ('__useDefault' in e ? e.__useDefault : e)); }; for (var zt = ['baseURL', 'map', 'paths', 'packages', 'packageConfigPaths', 'depCache', 'meta', 'bundles', 'transpiler', 'warnings', 'pluginFirst', 'production', 'wasm'], Jt = typeof Proxy !== 'undefined', Nt = 0; Nt < zt.length; Nt++)!(function (r) { Object.defineProperty(Ut.prototype, r, { get() { let e = Fe(this[W], r); return Jt && typeof e === 'object' && (e = new Proxy(e, { set(e, t) { throw new Error(`Cannot set SystemJS.${r}["${t}"] directly. Use SystemJS.config({ ${r}: { "${t}": ... } }) rather.`); } })), e; }, set(e) { throw new Error(`Setting \`SystemJS.${r}\` directly is no longer supported. Use \`SystemJS.config({ ${r}: ... })\`.`); } }); }(zt[Nt])); function $t(e, t) { Z.call(e[W], `SystemJS.${t} is deprecated for SystemJS.registry.${t}`); }Ut.prototype.delete = function (e) { return $t(this, 'delete'), this.registry.delete(e); }, Ut.prototype.get = function (e) { return $t(this, 'get'), this.registry.get(e); }, Ut.prototype.has = function (e) { return $t(this, 'has'), this.registry.has(e); }, Ut.prototype.set = function (e, t) { return $t(this, 'set'), this.registry.set(e, t); }, Ut.prototype.newModule = function (e) { return new j(e); }, Ut.prototype.isModule = function (e) { return e instanceof j || e[k] === 'module'; }, Ut.prototype.register = function (e, t, r) { return typeof e === 'string' && (e = me.call(this, this[W], e)), M.prototype.register.call(this, e, t, r); }, Ut.prototype.registerDynamic = function (e, t, r, n) { return typeof e === 'string' && (e = me.call(this, this[W], e)), M.prototype.registerDynamic.call(this, e, t, r, n); }, Ut.prototype.version = '0.21.6 Dev'; const Bt = new Ut(); (p || H) && (w.SystemJS = w.System = Bt), typeof module !== 'undefined' && module.exports && (module.exports = Bt); 
}());
